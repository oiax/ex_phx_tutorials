# リスト

## リストとは

リストは順序を持つ項の集合である。要素となる項の型に制限はない。次のように `[]` で囲んで記述する。

```elixir
[0, 1, 2, 3, 4, 5]
["alpha", "beta", "gamma"]
[true, "", :foo, nil]
```

リストを要素として持つリストを作ることもできる。

```elixir
[[0, 1], [2, 3], [4, 5]]
```

## 片方向連結リスト

Elixirのリスト `["x", "y", "z"]` のデータ構造は、次のように図示できる。

```
[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"
```

`[C]`、`[B]`、`[A]` は「consセル」と呼ばれる。`[C]` は、リストの最初の要素である文字列 `"x"` を参照しつつ、別の「consセル」である `[B]` を参照している。同様に、`[B]` は `"y"` と `[A]` を参照する。しかし、`[A]` は `"z"` を参照しているだけである。

このようなデータ構造を持つリストを「片方向連結リスト」と呼ぶ。

## リストの先頭に要素を追加する

Elixirのリストは項の一種であり、不変である。したがって、リストそれ自体に要素を追加することはできない。

他の多くのプログラミング言語では、リスト（配列）に要素を追加する仕組みがある。例えば、次のRubyコードでは変数 `a` が参照する配列の先頭に `"w"` という要素を加える。

```ruby
a = ["x", "y", "z"]
a.unshift("w")
```

Elixirではこのようなことはできない。しかし、次のような類似したコードを書くことが可能である。

```elixir
a = ["x", "y", "z"]
b = ["w" | a]
```

この結果、変数 `b` は `["w", "x", "y", "z"]` というリストを参照することになる。

変数 `a` が参照するリストは変化していない。このリストの先頭に `"w"` という要素が加わった別のリストが作られて、それと変数 `b` が結び付けられたということである。

* [05fd6a2](https://github.com/oiax/ex_phx_tutorials/commit/05fd6a231cd7f8388a98d0c352984486ca324c91) を適用。

```bash
$ mix run -e "Alpha.unshift()"
```

```
Compiling 1 file (.ex)
["w", "x", "y", "z"]
```

ここで行われた操作を図示すると次のようになる。

```
【初期状態】

      [C]-->[B]-->[A]-->nil
       |     |     |
      "x"   "y"   "z"

【結果】

[D]-->[C]-->[B]-->[A]-->nil
 |     |     |     |
"w"   "x"   "y"   "z"
```

初期状態では、変数 `a` は `[C]` を指していた。あらたに `[D]` が加えられてそれを変数 `b` が参照するようになった。

リスト `[x", "y", "z"]` から別のリスト `["w", "x", "y", "z"]` を作り出す際に、前のリストがそのまま利用されている。つまりデータの複製が発生していない。このような効率の良い操作が可能になるのは、すべての項が不変であるからである。

## リストの末尾に要素を追加する

リストの **末尾** に要素を追加する関数または演算子は用意されていない。しかし、リストとリストを連結する演算子 `++` を使えば、次のように書ける。

```elixir
a = ["x", "y", "z"]
b = a ++ ["w"]
```

* [05fd6a2](https://github.com/oiax/ex_phx_tutorials/commit/508c0e0efd39936ed6c5c13ea70b5adc1f31fd83) を適用。

```bash
$ mix run -e "Alpha.push()"
```

```
Compiling 1 file (.ex)
["x", "y", "z", "w"]
```

```
【初期状態】

[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"

【結果】
[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"   "w"
 |     |     |     |
[G]-->[F]-->[E]-->[D]-->nil
```

## 先頭の要素の取得

次のようにリストの **先頭** の要素を取得できる。

```
a = ["x", "y", "z"]
[b | _] = a
```

上記の結果、変数 `b` は `"x"` という文字列を参照することになる。変数 `a` が参照するリストは変化しない。

関数 `List.first/1` を使用してもよい。

```
a = ["x", "y", "z"]
b = List.first(a)
```

## 末尾の要素の取得

リストの **末尾** の要素を取得するには関数 `List.last/1` を使用する。下記の結果、変数 `b` は `"z"` という文字列を参照することになる。

```
a = ["x", "y", "z"]
b = List.last(a)
```

ただし、Elixirのリストは「連結リスト」であるため、リストのサイズが大きいとき関数 `List.last/1` の効率はよくない。

## 任意の位置の要素を取得する

リストから任意の位置の要素を取得するには、関数 `Enum.at/3` を使用する。第1引数に対象のリスト、第2引数にインデックス（0ベース）、省略可能な第3引数にはインデックスが範囲外のときに返すデフォルト値を指定する。

例えば、次のように書けば、変数 `b` にはリストの2番目の要素である `"y"` がセットされる。

```
a = ["x", "y", "z"]
b = Enum.at(a, 1)
```

ただし、Elixirのリストは「連結リスト」であるため、インデックスの値が大きいとき関数 `Enum.at/3` の効率はよくない。
