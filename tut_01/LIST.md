# リスト

## リストとは

リストは順序を持つ項の集合である。要素となる項の型に制限はない。次のように `[]` で囲んで記述する。

```elixir
[0, 1, 2, 3, 4, 5]
["alpha", "beta", "gamma"]
[true, "", :foo, nil]
```

リストを要素として持つリストを作ることもできる。

```elixir
[[0, 1], [2, 3], [4, 5]]
```

## 片方向連結リスト

Elixirのリスト `["x", "y", "z"]` のデータ構造は、次のように図示できる。

```
[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"
```

`[C]`、`[B]`、`[A]` は「consセル」と呼ばれる。`[C]` は、リストの最初の要素である文字列 `"x"` を参照しつつ、別の「consセル」である `[B]` を参照している。同様に、`[B]` は `"y"` と `[A]` を参照する。しかし、`[A]` は `"z"` を参照しているだけである。

このようなデータ構造を持つリストを「片方向連結リスト」と呼ぶ。

## リストの先頭に要素を追加する

Elixirのリストは項の一種であり、不変である。したがって、リストそれ自体に要素を追加することはできない。

他の多くのプログラミング言語では、リスト（配列）に要素を追加する仕組みがある。例えば、次のRubyコードでは変数 `a` が参照する配列の先頭に `"w"` という要素を加える。

```ruby
a = ["x", "y", "z"]
a.unshift("w")
```

Elixirではこのようなことはできない。しかし、次のような類似したコードを書くことが可能である。

```elixir
a = ["x", "y", "z"]
b = ["w" | a]
```

この結果、変数 `b` は `["w", "x", "y", "z"]` というリストを参照することになる。

変数 `a` が参照するリストは変化していない。このリストの先頭に `"w"` という要素が加わった別のリストが作られて、それと変数 `b` が結び付けられたということである。

* [05fd6a2](https://github.com/oiax/ex_phx_tutorials/commit/05fd6a231cd7f8388a98d0c352984486ca324c91) を適用。

```bash
$ mix run -e "Alpha.unshift()"
```

```
Compiling 1 file (.ex)
["w", "x", "y", "z"]
```

ここで行われた操作を図示すると次のようになる。

```
【初期状態】

      [C]-->[B]-->[A]-->nil
       |     |     |
      "x"   "y"   "z"

【結果】

[D]-->[C]-->[B]-->[A]-->nil
 |     |     |     |
"w"   "x"   "y"   "z"
```

初期状態では、変数 `a` は `[C]` を指していた。あらたに `[D]` が加えられてそれを変数 `b` が参照するようになった。

リスト `[x", "y", "z"]` から別のリスト `["w", "x", "y", "z"]` を作り出す際に、前のリストのデータ構造がそのまま利用されている。このような効率の良い操作が可能になるのは、すべての項が不変であるからである。

## リストの末尾に要素を追加する

リストの **末尾** に要素を追加する関数または演算子は用意されていない。しかし、リストとリストを連結する演算子 `++` を使えば、次のように書ける。

```elixir
a = ["x", "y", "z"]
b = a ++ ["w"]
```

* [05fd6a2](https://github.com/oiax/ex_phx_tutorials/commit/508c0e0efd39936ed6c5c13ea70b5adc1f31fd83) を適用。

```bash
$ mix run -e "Alpha.push()"
```

```
Compiling 1 file (.ex)
["x", "y", "z", "w"]
```

```
【初期状態】

[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"

【結果】
[C]-->[B]-->[A]-->nil
 |     |     |
"x"   "y"   "z"   "w"
 |     |     |     |
[G]-->[F]-->[E]-->[D]-->nil
```

リストの先頭に要素を追加する場合と異なり、consセルの列 `[G]-->[F]-->[E]` が作られており、その分だけ効率が落ちる。特に、巨大なリストの末尾に要素を追加するのは避けるべきである。

> 3つの文字列 `"x"`、`"y"`、`"z"` の複製が発生しない点に着目。Elixirの項は不変であるゆえに、複製が不要となる。

## 要素の取得

* `List.first(list)` - `list` から最初の要素を取得する
* `List.last(list)` - `list` から最後の要素を取得する
* `Enum.at(list, index, default \\ nil)` - `list` から任意の位置の要素を取得する

ただし、`index` は 0 ベースの添字。省略可能な引数 `default` は、`index` が範囲外のときに返すデフォルト値である。

例:

```elixir
a = ["x", "y", "z"]
b = List.first(a)
c = List.last(a)
d = Enum.at(a, 1)
```

上記の結果、変数 `b` は `"x"`、変数 `c` は `"z"`、変数 `d` は `"y"` を参照することになる。

ただし、Elixirのリストは「連結リスト」であるため、リストのサイズが大きいとき関数 `List.last/1` の効率はよくない。同様に、`index` の値が大きいとき関数 `Enum.at/3` の効率はよくない。

## 【参考】 パターンマッチングの利用

次のようにリストの **先頭** の要素を取得できる。

```
a = ["x", "y", "z"]
[b | _] = a
```

上記の結果、変数 `b` は `"x"` を参照することになる。
